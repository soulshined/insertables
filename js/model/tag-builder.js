/**
 * Minified by jsDelivr using Terser v5.7.1.
 * Original file: /npm/html-tag-builder@1.1.0/src/html-tag-builder.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const SELF_CLOSING = ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]; class Objects { static requireNonNull(e, t) { if (!this.isDefined(e)) throw new Error(`Null or undefined value not allowed for ${t}`); return e } static ofNullable(e, t) { return this.isDefined(e) || (e = Objects.requireNonNull(t, "defaultValue")), e } static isDefined(e) { return null != e } static isEmptyOrWhitespace(e) { return !this.isDefined(e) || "string" == typeof e && e.constructor === String && 0 === e.toString().trim().length } } class Attributes extends Map { clone() { const e = new Attributes; return this.forEach(((t, s) => e.set(s, t))), e } } class AbstractTagBuilder { constructor(e, t, s) { if (this._node = null, this._hNode = null, this._isCached = !1, Objects.requireNonNull(e, "tagName in TagBuilder"), e = e.trim().toLowerCase(), "headless" !== TagBuilderOptions.mode) { if (Objects.isEmptyOrWhitespace(s)) { const t = document.createElement(e); t.contentEditable = "inherit", t.draggable = !1, this.node = t } else { const t = document.createElementNS(s, e); this.node = t } if (!Objects.isEmptyOrWhitespace(t)) { if (null !== document.querySelector(`#${t}`)) throw new Error(`Tag with '${t}' id already exists in the document tree`); this.node.id = t } } else this.hNode = this.headlessBuilder(e, t, s) } attr(e, t) { return this.isHeadlessMode ? this.hNode.attr(e, t) : this.node.setAttribute(e, `${t}`), this } slot(e) { return this.isHeadlessMode ? this.hNode.attr("slot", e) : this.node.slot = e, this } tabIndex(e) { return this.isHeadlessMode ? this.hNode.attr("tabindex", e) : this.node.tabIndex = e, this } append(...e) { return 0 === (e = e.filter((e => Objects.isDefined(e)))).length ? this : this.isHeadlessMode ? (this.hNode.append(...e.map((e => e instanceof AbstractTagBuilder ? e.buildHTML() : e))), this) : (this.node.append(...e.map((e => e instanceof AbstractTagBuilder ? e.build() : e))), this) } prepend(...e) { return 0 === (e = e.filter((e => Objects.isDefined(e)))).length ? this : this.isHeadlessMode ? (this.hNode.prepend(...e.map((e => e instanceof AbstractTagBuilder ? e.buildHTML() : e))), this) : (this.node.prepend(...e.map((e => e instanceof AbstractTagBuilder ? e.build() : e))), this) } insertAdjacent(e, t = "after") { return this.isHeadlessMode ? this.hNode.insertAdjacent(e.buildHTML(), "before" === t ? "before" : "after") : this.node.insertAdjacentElement("before" === t ? "beforebegin" : "afterend", e.build()), this } innerHTML(e) { return this.isHeadlessMode ? this.hNode.innerHTML(e) : this.node.innerHTML = e, this } classes(...e) { if (!Array.isArray(e)) throw new Error(`Invalid datatype for classes. Got '${typeof e}' expecting array of strings for node: [type = '${this.node.nodeType}', tagName = '${this.node.tagName}']`); return this.isHeadlessMode ? (this.hNode.classes(e), this) : (e.forEach((e => { if ("string" != typeof e || e.constructor !== String) throw new Error(`Invalid datatype for class name. Got '${typeof e}' expecting string for node: [type = '${this.node.nodeType}', tagName = '${this.node.tagName}']`); this.node.classList.contains(e) || this.node.classList.add(e) })), this) } margin(...e) { return e.length > 4 || 0 === e.length || this.style({ margin: e.join(" ") }), this } origin(e, t, s, i) { return Objects.isEmptyOrWhitespace(e) || this.style({ top: e }), Objects.isEmptyOrWhitespace(t) || this.style({ right: t }), Objects.isEmptyOrWhitespace(s) || this.style({ bottom: s }), Objects.isEmptyOrWhitespace(i) || this.style({ left: i }), this } padding(...e) { return e.length > 4 || 0 === e.length || this.style({ padding: e.join(" ") }), this } position(e) { return this.style({ position: e }), this } style(e) { for (const [t, s] of Object.entries(e)) "undefined" !== t && "null" !== t && Objects.isDefined(s) && (this.isHeadlessMode ? this.hNode.style(t, s) : window.CSS.supports(t, s.toString()) ? this.node.style[t] = s.toString() : console.debug(`Entry/value is not supported => ${t} : ${s}`)); return this } on(e, t, s) { return this.isHeadlessMode ? this.hNode.attr(`on${e}`.toLowerCase(), t) : this.node.addEventListener(e, t, s), this } build() { return this.node } buildHTML() { return this.isHeadlessMode ? this.hNode.build() : this.build().outerHTML } get isSVGElement() { return this.node instanceof SVGElement } get isCached() { return this._isCached } set isCached(e) { this._isCached = e } get node() { return this._node } set node(e) { this._node = e } get hNode() { return this._hNode } set hNode(e) { this._hNode = e } get tagName() { return this.isHeadlessMode ? this.hNode.tagName().toUpperCase() : this.node.tagName } get tagId() { return this.isHeadlessMode ? this.hNode.tagId() : this.node.id } get isHeadlessMode() { return "headless" === TagBuilderOptions.mode || Objects.isDefined(this.hNode) } headlessBuilder(e, t, s) { class i { constructor(e, t) { this._attrs = new Attributes, this._children = [], this._siblings = new Attributes([["before", []], ["after", []]]), this._styles = new Attributes, this._tagName = e, Objects.isEmptyOrWhitespace(t) || this.attrs.set("id", t), Objects.isEmptyOrWhitespace(s) ? this.attrs.set("draggable", !1) : this.attrs.set("xmlns", s), this.attrs.set("class", new Set) } get tagName() { return this._tagName } get attrs() { return this._attrs } get children() { return this._children } get siblings() { return this._siblings } get styles() { return this._styles } get classes() { return this.attrs.get("class") } static from(e) { const t = new i(e._tagName, e.attrs.get("id")); return t._attrs = e.attrs.clone(), t._children = [...e._children], t._siblings = e._siblings.clone(), t._styles = e._styles.clone(), t } } const r = function (e, t, s) { let d = new i(e, t); return null != s && (d = i.from(s)), { attr: function (e, t) { return d.attrs.set(e, `${t}`), this }, append: function (...e) { return d.children.push(...e), this }, prepend: function (...e) { return d.children.unshift(...e), this }, insertAdjacent: function (e, t) { return d.siblings.get(t).push(e), this }, innerHTML: function (e) { return d.children.splice(0, d.children.length, e), this }, classes: function (t) { return t.forEach((t => { if ("string" != typeof t || t.constructor !== String) throw new Error(`Invalid datatype for class name. Got '${typeof t}' expecting string for node: [tagName = '${e}']`); d.classes.add(t.trim()) })), this }, style: function (e, t) { return Objects.isDefined(e) && Objects.isDefined(t) ? (d.styles.set(e, `${t}`), this) : this }, tagName: () => d.tagName, tagId: () => { var e; return null != (e = d.attrs.get("id")) ? e : null }, clone: function () { return r(e, t, d) }, build: () => { let t = ""; if (d.attrs.forEach(((e, s) => { "class" !== s.trim() ? (e = Objects.isEmptyOrWhitespace(e) ? "" : e, t += ` ${s}="${e}"`) : e.size > 0 && (t += ` class="${[...e].join(" ")}"`) })), d.styles.size > 0) { t += ' style="'; let e = ""; d.styles.forEach(((t, s) => { t = Objects.isEmptyOrWhitespace(t) ? "" : t, e += ` ${s.trim()}: ${t.trim()};` })), t += `${e.trim()}"` } return SELF_CLOSING.includes(e) ? `<${e}${t}>` : d.siblings.get("before").join() + `<${e}${t}>` + (0 === d.children.length ? "" : d.children.join("")) + `</${e}>` + d.siblings.get("after").join() } } }; return r(e, t) } } class TagBuilder extends AbstractTagBuilder { constructor(e, t) { super(e, t) } accessKey(e) { return this.isHeadlessMode ? this.hNode.attr("accesskey", e) : this.node.accessKey = e.trim(), this } inputMode(e = "text") { return e = Objects.ofNullable(e, "text"), this.isHeadlessMode ? this.hNode.attr("inputmode", e) : this.node.inputMode = e, this } contentEditable() { return this.isHeadlessMode ? this.hNode.attr("contenteditable", !0) : this.node.contentEditable = "true", this } dir(e) { return this.isHeadlessMode ? this.hNode.attr("dir", e) : this.node.dir = e, this } draggable() { return this.isHeadlessMode ? this.hNode.attr("draggable", !0) : this.node.draggable = !0, this } hidden() { return this.isHeadlessMode ? this.hNode.attr("hidden", !0) : this.node.hidden = !0, this } spellcheck() { return this.isHeadlessMode ? this.hNode.attr("spellcheck", !0) : this.node.spellcheck = !0, this } title(e) { return this.isHeadlessMode ? this.hNode.attr("title", e) : this.node.title = e, this } innerText(e) { return this.isHeadlessMode ? this.hNode.innerHTML(e) : this.node.innerText = e, this } autocapitalize(e) { return this.isHeadlessMode ? this.hNode.attr("autocapitalize", e) : this.node.autocapitalize = e, this } bounds(e, t) { return this.style({ width: e, height: t }), this } caret(e) { return this.style({ "caret-color": e }), this } height(e) { return this.style({ height: e }), this } textcase(e) { return ["uppercase", "lowercase", "none", "capitalize", "inherit"].includes(e) && this.style({ "text-transform": e }), this } visibility(e) { return this.style({ visibility: e }), this } width(e) { return this.style({ width: e }), this } screenReaderOnly() { return this.style({ border: 0, clip: "rect(0 0 0 0)", height: "1px", margin: "-1px", overflow: "hidden", padding: 0, position: "absolute", width: "1px" }), this } clone() { const e = new TagBuilder(this.tagName, this.tagId); return e.isCached = this.isCached, this.isHeadlessMode ? e.hNode = this.hNode.clone() : e.node = this.node.cloneNode(!0), e } static parse(e) { if ("headless" === TagBuilderOptions.mode) throw new Error("Parse is not supported in headless mode"); const t = document.createElement("template"); t.innerHTML = e; const s = t.content.childNodes; if (0 === s.length) return null; const i = [...s].filter((e => 1 === e.nodeType)).map((e => { const t = new TagBuilder(e.tagName, e.id); return Object.entries(e.attributes).forEach((e => { t.attr(e[1].name, e[1].value) })), t.node.append(...e.children), t })); return 0 === i.length ? null : i } } class TagBuilderOptions { static get mode() { return this._mode } static set mode(e) { this._mode = e } static get scriptAsync() { return this._defaultScriptAsync } static set scriptAsync(e) { this._defaultScriptAsync = e } static get useOptionContentForEmptyOptionValue() { return this._useOptionContentForEmptyOptionValue } static set useOptionContentForEmptyOptionValue(e) { this._useOptionContentForEmptyOptionValue = e } static get defaultInputType() { return this._defaultInputType } static set defaultInputType(e) { this._defaultInputType = e } static reset() { this._defaultInputType = "text", this._useOptionContentForEmptyOptionValue = !0, this._defaultScriptAsync = !0 } } TagBuilderOptions._defaultInputType = "text", TagBuilderOptions._useOptionContentForEmptyOptionValue = !0, TagBuilderOptions._defaultScriptAsync = !0; class BlockquoteBuilder extends TagBuilder { constructor(e, t) { super("blockquote", t), this.isHeadlessMode ? this.attr("cite", e) : this.node.cite = e } } class FieldsetBuilder extends TagBuilder { constructor(e, t) { super("fieldset", t), Objects.isEmptyOrWhitespace(e) || this.append(new TagBuilder("legend").innerText(e)) } } class FigureBuilder extends TagBuilder { constructor(e, t = "bottom", s) { super("figure", s), this.caption = new TagBuilder("figcaption"), this.captionPlacement = "bottom", Objects.isEmptyOrWhitespace(e) || this.caption.innerHTML(e), this.captionPlacement = t } clone() { const e = new FigureBuilder; return e.caption = this.caption, e.captionPlacement = this.captionPlacement, e.isCached = this.isCached, this.isHeadlessMode ? e.hNode = this.hNode.clone() : e.node = this.node.cloneNode(!0), e } build() { return this.isCached || (this.isCached = !0, "bottom" === this.captionPlacement ? this.append(this.caption) : this.prepend(this.caption)), this.node } buildHTML() { return this.isCached ? this.isHeadlessMode ? this.hNode.build() : this.node.outerHTML : (this.isCached = !0, "bottom" === this.captionPlacement ? this.append(this.caption) : this.prepend(this.caption), this.hNode.build()) } } class AnchorBuilder extends TagBuilder { constructor(e, t = "_self", s) { super("a", s), e = Objects.requireNonNull(e, "href"), t = Objects.requireNonNull(t, "target"), this.isHeadlessMode ? (this.attr("href", e), this.attr("target", t)) : (this.node.href = e, this.node.target = t) } hreflang(e) { return this.isHeadlessMode ? this.attr("hreflang", e) : this.node.hreflang = e, this } mimeType(e) { return this.isHeadlessMode ? this.attr("type", e) : this.node.type = e, this } ping(e) { return this.isHeadlessMode ? this.attr("ping", e.join(" ")) : this.node.ping = e.join(" "), this } rel(e) { return this.isHeadlessMode ? this.attr("rel", e) : this.node.rel = e, this } } class DownloadLinkBuilder extends AnchorBuilder { constructor(e, t, s) { super(e, "_self", s), t = Objects.requireNonNull(t, "filename in DownloadLinkBuilder"), this.isHeadlessMode ? this.attr("download", t) : this.node.download = t } } class AreaBuilder extends TagBuilder { constructor(e, t = "default", s) { super("area", s), e = Objects.requireNonNull(e, "coords"), this.isHeadlessMode ? (this.attr("coords", e), Objects.isDefined(t) && this.attr("shape", t)) : (this.node.coords = e, Objects.isDefined(t) && (this.node.shape = t)) } href(e, t) { return e = Objects.requireNonNull(e, "href"), t = Objects.requireNonNull(t, "alt"), this.isHeadlessMode ? (this.attr("href", e), this.attr("alt", t)) : (this.node.href = e, this.node.alt = t), this } hreflang(e) { return this.attr("hreflang", e), this } ping(e) { return this.isHeadlessMode ? this.attr("ping", e.join(" ")) : this.node.ping = e.join(" "), this } rel(e) { return this.isHeadlessMode ? this.attr("rel", e) : this.node.rel = e, this } target(e) { return this.isHeadlessMode ? this.attr("target", e) : this.node.target = e, this } } class DownloadAreaBuilder extends AreaBuilder { constructor(e, t, s = "default", i) { super(t, s, i), e = Objects.requireNonNull(e, "filename in DownloadAreaBuilder"), this.isHeadlessMode ? this.attr("download", e) : this.node.download = e } } class DataBuilder extends TagBuilder { constructor(e, t) { super("data", t), this.isHeadlessMode ? this.attr("value", e) : this.node.value = e } } class SpanBuilder extends TagBuilder { constructor(e, t) { super("span", t), Objects.isDefined(e) && (e.sort(), e.forEach((e => { "bold" === e ? this.bold() : "bolder" === e ? this.bolder() : "lighter" === e ? this.lighter() : "italic" === e ? this.italic() : "underline" === e ? this.underline() : "strikethrough" === e && this.strikethrough() }))) } bold() { return this.style({ "font-weight": "bold" }), this } bolder() { return this.style({ "font-weight": "bolder" }), this } italic() { return this.style({ "font-style": "italic" }), this } lighter() { return this.style({ "font-weight": "lighter" }), this } underline() { return this.style({ "text-decoration": "underline" }), this } strikethrough() { return this.style({ "text-decoration": "strikethrough" }), this } color(e) { return this.style({ color: e }), this } } class InputBuilder extends TagBuilder { constructor(e, t) { super("input", t), this.isHeadlessMode ? (this.attr("spellcheck", !1), this.attr("checked", !1), this.attr("required", !1), this.attr("type", null != e ? e : TagBuilderOptions.defaultInputType)) : (this.node.spellcheck = !1, this.node.checked = !1, this.node.required = !1, this.node.type = null != e ? e : TagBuilderOptions.defaultInputType) } autocomplete(e) { return this.isHeadlessMode ? this.attr("autocomplete", e) : this.node.autocomplete = e, this } autofocus() { return this.isHeadlessMode ? this.attr("autofocus", !0) : this.node.autofocus = !0, this } datalist(e) { return this.attr("list", Objects.requireNonNull(e, "id")), this } disabled() { return this.isHeadlessMode ? this.attr("disabled", !0) : this.node.disabled = !0, this } name(e) { return this.isHeadlessMode ? this.attr("name", e) : this.node.name = e, this } onInvalid(e) { return this.isHeadlessMode ? this.attr("oninvalid", `this.setCustomValidity('${e}');`) : this.node.setCustomValidity(e), this } placeholder(e) { return this.isHeadlessMode ? this.attr("placeholder", e) : this.node.placeholder = e, this } readOnly() { return this.isHeadlessMode ? this.attr("readonly", !0) : this.node.readOnly = !0, this } required() { return this.isHeadlessMode ? this.attr("required", !0) : this.node.required = !0, this } value(e) { return this.isHeadlessMode ? this.attr("value", e) : this.node.value = e, this } } class NumberInputBuilder extends InputBuilder { constructor(e, t) { super("number", t), Objects.isDefined(e) && (this.isHeadlessMode ? this.attr("value", e) : this.node.value = e) } min(e) { return this.isHeadlessMode ? this.attr("min", e) : this.node.min = e, this } max(e) { return this.isHeadlessMode ? this.attr("max", e) : this.node.max = e, this } step(e) { return this.isHeadlessMode ? this.attr("step", e) : this.node.step = e, this } } class RangeInputBuilder extends NumberInputBuilder { constructor(e, t) { super(e, t), this.isHeadlessMode ? this.attr("type", "range") : this.node.type = "range" } } class CheckboxInputBuilder extends InputBuilder { constructor(e = !1, t) { super("checkbox", t), this.isHeadlessMode || (this.node.indeterminate = e) } checked() { return this.isHeadlessMode ? this.attr("checked", !0) : this.node.checked = !0, this } } class RadioInputBuilder extends InputBuilder { constructor(e, t) { super("radio", t), e = Objects.ofNullable(e, !1), this.isHeadlessMode ? this.attr("checked", e) : this.node.checked = e } } class DateInputBuilder extends NumberInputBuilder { constructor(e, t) { super(e, t), this.isHeadlessMode ? this.attr("type", "date") : this.node.type = "date" } } class DateTimeLocalInputBuilder extends DateInputBuilder { constructor(e, t) { super(e, t), this.isHeadlessMode ? this.attr("type", "datetime-local") : this.node.type = "datetime-local" } } class MonthInputBuilder extends DateInputBuilder { constructor(e, t) { super(e, t), this.isHeadlessMode ? this.attr("type", "month") : this.node.type = "month" } } class TimeInputBuilder extends DateInputBuilder { constructor(e, t) { super(e, t), this.isHeadlessMode ? this.attr("type", "time") : this.node.type = "time" } } class WeekInputBuilder extends DateInputBuilder { constructor(e, t) { super(e, t), this.isHeadlessMode ? this.attr("type", "week") : this.node.type = "week" } } class FileInputBuilder extends InputBuilder { constructor(e, t) { super("file", t), this.isHeadlessMode ? (this.attr("multiple", !1), this.attr("accept", Objects.ofNullable(e, ""))) : (this.node.multiple = !1, Objects.isDefined(e) && (this.node.accept = e)) } capture(e) { return this.attr("capture", e), this } multiple() { return this.isHeadlessMode ? this.attr("multiple", !0) : this.node.multiple = !0, this } } class ImageInputBuilder extends InputBuilder { constructor(e, t, s) { super("image", s), e = Objects.requireNonNull(e, "src"), t = Objects.requireNonNull(t, "alt"), this.isHeadlessMode ? (this.attr("src", e), this.attr("alt", t)) : (this.node.src = e, this.node.alt = t) } formAction(e) { return this.isHeadlessMode ? this.attr("formaction", e) : this.node.formAction = e, this } formEnctype(e) { return e = Objects.ofNullable(e, "application/x-www-form-urlencoded"), this.isHeadlessMode ? this.attr("formenctype", e) : this.node.formEnctype = e, this } formMethod(e) { return this.isHeadlessMode ? this.attr("formmethod", e) : this.node.formMethod = e, this } } class TextInputBuilder extends InputBuilder { constructor(e) { super("text", e) } maxLength(e) { return this.isHeadlessMode ? this.attr("maxlength", e) : this.node.maxLength = e, this } minLength(e) { return this.isHeadlessMode ? this.attr("minlength", e) : this.node.minLength = e, this } pattern(e) { const t = e instanceof RegExp ? e.source : new RegExp(e).source; return this.isHeadlessMode ? this.attr("pattern", t) : this.node.pattern = t, this } size(e) { return this.isHeadlessMode ? this.attr("size", e) : this.node.size = e, this } } class EmailInputBuilder extends TextInputBuilder { constructor(e) { super(e), this.isHeadlessMode ? (this.attr("type", "email"), this.attr("multiple", !1)) : (this.node.type = "email", this.node.multiple = !1) } multiple() { return this.isHeadlessMode ? this.attr("multiple", !0) : this.node.multiple = !0, this } } class PasswordInputBuilder extends TextInputBuilder { constructor(e) { super(e), this.isHeadlessMode ? this.attr("type", "password") : this.node.type = "password" } } class SearchInputBuilder extends TextInputBuilder { constructor(e) { super(e), this.isHeadlessMode ? this.attr("type", "search") : this.node.type = "search" } } class TelInputBuilder extends TextInputBuilder { constructor(e) { super(e), this.isHeadlessMode ? this.attr("type", "tel") : this.node.type = "tel" } } class UrlInputBuilder extends TextInputBuilder { constructor(e) { super(e), this.isHeadlessMode ? this.attr("type", "url") : this.node.type = "url" } } class TextAreaBuilder extends TagBuilder { constructor(e, t, s) { super("textarea", s), this.isHeadlessMode ? (this.attr("spellcheck", !1), this.attr("required", !1), Objects.isDefined(e) && this.attr("rows", e), Objects.isDefined(t) && this.attr("cols", t)) : (this.node.spellcheck = !1, this.node.required = !1, Objects.isDefined(e) && (this.node.rows = e), Objects.isDefined(t) && (this.node.cols = t)) } autocomplete(e) { return this.isHeadlessMode ? this.attr("autocomplete", e) : this.node.autocomplete = e, this } autofocus() { return this.isHeadlessMode ? this.attr("autofocus", !0) : this.node.autofocus = !0, this } disabled() { return this.isHeadlessMode ? this.attr("disabled", !0) : this.node.disabled = !0, this } maxLength(e) { return this.isHeadlessMode ? this.attr("maxlength", e) : this.node.maxLength = e, this } minLength(e) { return this.isHeadlessMode ? this.attr("minlength", e) : this.node.minLength = e, this } name(e) { return this.isHeadlessMode ? this.attr("name", e) : this.node.name = e, this } onInvalid(e) { return this.isHeadlessMode ? this.attr("oninvalid", `this.setCustomValidity('${e}');`) : this.node.setCustomValidity(e), this } placeholder(e) { return this.isHeadlessMode ? this.attr("placeholder", e) : this.node.placeholder = e, this } readOnly() { return this.isHeadlessMode ? this.attr("readonly", !0) : this.node.readOnly = !0, this } required() { return this.isHeadlessMode ? this.attr("required", !0) : this.node.required = !0, this } value(e) { return this.isHeadlessMode ? this.attr("value", e) : this.node.value = e, this } wrap(e) { return this.isHeadlessMode ? this.attr("wrap", e) : this.node.wrap = e, this } } class DataListBuilder extends TagBuilder { constructor(e) { super("datalist", e), Objects.requireNonNull(e, "id in DatalistBuilder") } addOption(e, t, s = []) { return Objects.requireNonNull(e, "content in DatalistBuilder"), this.addOptions(new OptionBuilder(e, t).classes(...s)), this } addOptions(...e) { return e.forEach((e => { e instanceof OptionBuilder ? this.append(e) : this.append(new OptionBuilder(e)) })), this } } class DLBuilder extends TagBuilder { constructor(e = !1, t = [], s) { super("dl", s), this.div = null, !0 === e && (this.div = new TagBuilder("div").classes(...t)) } addTerm(e, ...t) { Objects.requireNonNull(e, "term in DLBuilder"); const s = new TagBuilder("dt").innerHTML(e), i = t.map((e => e instanceof TagBuilder ? "DD" === e.tagName ? e : new TagBuilder("dd").append(e) : new TagBuilder("dd").innerHTML(e))); return null !== this.div ? this.append(this.div.clone().append(s, ...i)) : this.append(s, ...i), this } clone() { const e = new DLBuilder(!1); return e.div = this.div, this.isHeadlessMode ? e.hNode = this.hNode.clone() : e.node = this.node.cloneNode(!0), e } } class DetailsBuilder extends TagBuilder { constructor(e, t = !1, s) { super("details", s), this.isHeadlessMode ? this.attr("open", t) : this.node.open = t, Objects.isDefined(e) && this.prepend(new TagBuilder("summary").innerHTML(e)) } } class OptionBuilder extends TagBuilder { constructor(e, t, s) { super("option", s), this.innerHTML(e), !Objects.isDefined(t) && TagBuilderOptions.useOptionContentForEmptyOptionValue ? this.attr("value", e.trim().toLowerCase().replace(/\s+/g, "-")) : this.attr("value", Objects.ofNullable(t, "")) } } class SelectBuilder extends TagBuilder { constructor(e, t) { super("select", t), this.isHeadlessMode ? (this.attr("spellcheck", !1), this.attr("required", !1)) : (this.node.spellcheck = !1, this.node.required = !1), Objects.isDefined(e) && this.append(new OptionBuilder(e, "").attr("disabled", "")) } addOptionGroup(e, ...t) { return Objects.requireNonNull(e, "label in SelectBuilder"), this.append(new TagBuilder("optgroup").attr("label", e).append(...t)), this } addOption(e, t, s) { return this.addOptions([new OptionBuilder(e, t).classes(...s)]), this } addOptions(e) { return e.forEach((e => { e instanceof OptionBuilder ? this.append(e) : this.append(new OptionBuilder(e)) })), this } autocomplete(e) { return this.isHeadlessMode ? this.attr("autocomplete", e) : this.node.autocomplete = e, this } autofocus() { return this.isHeadlessMode ? this.attr("autofocus", !0) : this.node.autofocus = !0, this } disabled() { return this.isHeadlessMode ? this.attr("disabled", !0) : this.node.disabled = !0, this } multiple() { return this.isHeadlessMode ? this.attr("multiple", !0) : this.node.multiple = !0, this } name(e) { return this.isHeadlessMode ? this.attr("name", e) : this.node.name = e, this } onInvalid(e) { return this.isHeadlessMode ? this.attr("oninvalid", `this.setCustomValidity('${e}');`) : this.node.setCustomValidity(e), this } required() { return this.isHeadlessMode ? this.attr("required", !0) : this.node.required = !0, this } size(e) { return this.isHeadlessMode ? this.attr("size", e) : this.node.size = e, this } } class ListItemBuilder extends TagBuilder { constructor(e, t) { super("li", t), this.innerHTML(Objects.ofNullable(e, "")) } } class ListBuilder extends TagBuilder { constructor(e = !1, t = "none", s) { super(e ? "ol" : "ul", s), Objects.isDefined(t) && "none" !== t.toLowerCase() && this.style({ "list-style": t }) } addItem(e) { return e instanceof ListItemBuilder ? this.append(e) : this.append(new ListItemBuilder(e)), this } addItems(e) { return e.forEach((e => this.addItem(e))), this } addSublist(e) { return this.append(new TagBuilder("li").append(e)), this } } class AudioBuilder extends TagBuilder { constructor(e, t) { super("audio", t), e = Objects.requireNonNull(e, "src"), this.isHeadlessMode ? (this.attr("src", e), this.attr("controls", !0)) : (this.node.src = e, this.node.controls = !0) } addFallbackSrc(e, t) { return this.append(new SourceBuilder(e, t)), this } loop() { return this.isHeadlessMode ? this.attr("loop", !0) : this.node.loop = !0, this } muted() { return this.isHeadlessMode ? this.attr("muted", !0) : this.node.muted = !0, this } noControls() { return this.isHeadlessMode ? this.attr("controls", !1) : this.node.controls = !1, this } onNotSupported(e) { return this.fallbackHTML = e, this } preload(e) { return this.isHeadlessMode ? this.attr("preload", e) : this.node.preload = e, this } track(e, t, s = !1, i = "en", r) { return this.append(new TagBuilder("track").attr("kind", t).attr("srclang", i).attr("src", e).attr("label", r).attr("default", s)), this } clone() { var e, t; const s = new AudioBuilder(null != (t = null === (e = this.node) || void 0 === e ? void 0 : e.src) ? t : "", this.tagId); return s.fallbackHTML = this.fallbackHTML, s.isCached = this.isCached, this.isHeadlessMode ? s.hNode = this.hNode.clone() : s.node = this.node.cloneNode(!0), s } build() { return this.isCached || (this.isCached = !0, Objects.isDefined(this.fallbackHTML) && this.append(this.fallbackHTML)), this.node } buildHTML() { return this.isCached || (this.isCached = !0, Objects.isDefined(this.fallbackHTML) && this.append(this.fallbackHTML)), this.isHeadlessMode ? this.hNode.build() : this.node.outerHTML } } class EmbedBuilder extends TagBuilder { constructor(e, t, s) { super("embed", s), e = Objects.requireNonNull(e, "src in EmbedBuilder"), t = Objects.requireNonNull(t, "type in EmbedBuilder"), this.isHeadlessMode ? (this.attr("src", e), this.attr("type", t)) : (this.node.src = e, this.node.type = t) } } class IframeBuilder extends TagBuilder { constructor(e, t) { super("iframe", t), e = Objects.requireNonNull(e, "src"), this.isHeadlessMode ? this.attr("src", e) : this.node.src = e } allow(e) { return this.isHeadlessMode ? this.attr("allow", e) : this.node.allow = e, this } referrerPolicy(e = "no-referrer-when-downgrade") { return e = Objects.ofNullable(e, "no-referrer-when-downgrade"), this.isHeadlessMode ? this.attr("referrerpolicy", e) : this.node.referrerPolicy = e, this } sandbox(e = "") { return this.attr("sandbox", e), this } srcdoc(e) { return this.isHeadlessMode ? this.attr("srcdoc", e) : this.node.srcdoc = e, this } } class ImageBuilder extends TagBuilder { constructor(e, t, s) { super("img", s), e = Objects.requireNonNull(e, "src"), t = Objects.requireNonNull(t, "alt"), this.isHeadlessMode ? (this.attr("src", e), this.attr("alt", t), this.attr("title", t)) : (this.node.src = e, this.node.alt = t, this.node.title = t) } decoding(e) { return this.isHeadlessMode ? this.attr("decoding", e) : this.node.decoding = e, this } sizes(e) { return this.isHeadlessMode ? this.attr("sizes", e) : this.node.sizes = e, this } srcset(e) { return this.isHeadlessMode ? this.attr("srcset", e) : this.node.srcset = e, this } } class PictureBuilder extends TagBuilder { constructor(e, t) { super("picture", t), this.img = e } source(...e) { return this.append(...e), this } clone() { const e = new PictureBuilder(this.img); return e.isCached = this.isCached, e.img = this.img.clone(), this.isHeadlessMode ? e.hNode = this.hNode.clone() : e.node = this.node.cloneNode(!0), e } build() { return this.isCached || (this.isCached = !0, this.append(this.img)), this.node } buildHTML() { return this.isCached || (this.isCached = !0, this.append(this.img)), this.isHeadlessMode ? this.hNode.build() : this.node.outerHTML } } class SourceBuilder extends TagBuilder { constructor(e, t, s) { super("source", s), e = Objects.requireNonNull(e, "src"), t = Objects.requireNonNull(t, "type"), this.isHeadlessMode ? (this.attr("src", e), this.attr("type", t)) : (this.node.src = e, this.node.type = t) } media(e) { return this.isHeadlessMode ? this.attr("media", e) : this.node.media = e, this } sizes(e) { return this.isHeadlessMode ? this.attr("sizes", e) : this.node.sizes = e, this } srcset(e) { return this.isHeadlessMode ? this.attr("srcset", e) : this.node.srcset = e, this } } class VideoBuilder extends TagBuilder { constructor(e, t, s) { super("video", s), e = Objects.requireNonNull(e, "src"), this.attr("type", Objects.requireNonNull(t, "type")), this.isHeadlessMode ? (this.attr("src", e), this.attr("controls", !0)) : (this.node.src = e, this.node.controls = !0) } addFallbackSrc(e, t) { return this.append(new SourceBuilder(e, t)), this } loop() { return this.isHeadlessMode ? this.attr("loop", !0) : this.node.loop = !0, this } muted() { return this.isHeadlessMode ? this.attr("muted", !0) : this.node.muted = !0, this } noControls() { return this.isHeadlessMode ? this.attr("controls", !1) : this.node.controls = !1, this } onNotSupported(e) { return this.fallbackHTML = e, this } poster(e) { return e = Objects.requireNonNull(e, "poster"), this.isHeadlessMode ? this.attr("poster", e) : this.node.poster = e, this } preload(e) { return this.isHeadlessMode ? this.attr("preload", e) : this.node.preload = e, this } track(e, t, s = !1, i = "en", r) { return this.append(new TagBuilder("track").attr("kind", t).attr("srclang", i).attr("src", e).attr("label", r).attr("default", s)), this } clone() { var e, t, s, i; const r = new VideoBuilder(null != (t = null === (e = this.node) || void 0 === e ? void 0 : e.src) ? t : "", null != (i = null === (s = this.node) || void 0 === s ? void 0 : s.getAttribute("type")) ? i : ""); return r.fallbackHTML = this.fallbackHTML, r.isCached = this.isCached, this.isHeadlessMode ? r.hNode = this.hNode.clone() : r.node = this.node.cloneNode(!0), r } build() { return this.isCached || (this.isCached = !0, Objects.isDefined(this.fallbackHTML) && this.append(this.fallbackHTML)), this.node } buildHTML() { return this.isCached || (this.isCached = !0, this.append(this.fallbackHTML)), this.isHeadlessMode ? this.hNode.build() : this.node.outerHTML } } class MeterBuilder extends TagBuilder { constructor(e) { super("meter", e) } min(e) { return this.isHeadlessMode ? this.attr("min", e) : this.node.min = e, this } max(e) { return this.isHeadlessMode ? this.attr("max", e) : this.node.max = e, this } minmax(e, t) { return this.min(e).max(t) } low(e) { return this.isHeadlessMode ? this.attr("low", e) : this.node.low = e, this } high(e) { return this.isHeadlessMode ? this.attr("high", e) : this.node.high = e, this } lowhigh(e, t) { return this.low(e).high(t) } optimum(e) { return this.isHeadlessMode ? this.attr("optimum", e) : this.node.optimum = e, this } } class ProgressBuilder extends TagBuilder { constructor(e, t) { super("progress", t), e = Objects.requireNonNull(e, "value"), this.isHeadlessMode ? this.attr("value", e) : this.node.value = e } max(e) { return this.isHeadlessMode ? this.attr("max", e) : this.node.max = e, this } } class FormBuilder extends TagBuilder { constructor(e, t = "get", s) { super("form", s), t = Objects.ofNullable(t, "get"), e = Objects.requireNonNull(e, "actionUrl of FormBuilder"), this.isHeadlessMode ? (this.attr("method", t), this.attr("action", e)) : (this.node.method = t, this.node.action = e) } acceptCharset(...e) { return this.isHeadlessMode ? this.attr("acceptcharset", e.join(" ")) : this.node.acceptCharset = e.join(" "), this } enctype(e) { return e = Objects.ofNullable(e, "application/x-www-form-urlencoded"), this.isHeadlessMode ? this.attr("enctype", e) : this.node.enctype = e, this } rel(e) { return this.attr("rel", e), this } target(e) { return this.isHeadlessMode ? this.attr("target", e) : this.node.target = e, this } noValidate() { return this.isHeadlessMode ? this.attr("novalidate", !0) : this.node.noValidate = !0, this } } class ScriptBuilder extends TagBuilder { constructor(e) { super("script", e), this.isHeadlessMode ? this.attr("async", TagBuilderOptions.scriptAsync) : this.node.async = TagBuilderOptions.scriptAsync } async() { return this.isHeadlessMode ? this.attr("async", !0) : this.node.async = !0, this } crossOrigin(e) { return e = Objects.ofNullable(e, ""), this.isHeadlessMode ? this.attr("crossorigin", e) : this.node.crossOrigin = e, this } defer() { return this.isHeadlessMode ? this.attr("defer", !0) : this.node.defer = !0, this } integrity(e) { return this.isHeadlessMode ? this.attr("integrity", e) : this.node.integrity = e, this } noModule() { return this.isHeadlessMode ? this.attr("nomodule", !0) : this.node.noModule = !0, this } nonce(e) { return this.isHeadlessMode ? this.attr("nonce", e) : this.node.nonce = e, this } referrerPolicy(e) { return e = Objects.ofNullable(e, ""), this.isHeadlessMode ? this.attr("referrerpolicy", e) : this.node.referrerPolicy = e, this } src(e) { return this.isHeadlessMode ? this.attr("src", e) : this.node.src = e, this } type(e) { return this.isHeadlessMode ? this.attr("type", e) : this.node.type = e, this } } class ColGroupBuilder extends TagBuilder { constructor(e) { super("colgroup", e) } addCol(e, ...t) { const s = new TagBuilder("col").classes(...t); return Objects.isDefined(e) && s.attr("span", e), this.append(s), this } } class TableBuilder extends TagBuilder { constructor(e, t) { super("table", t), this.header = null, this.body = null, this.caption = null, this.colGroupBuilder = null, this.isHeadlessMode ? (this.header = new TagBuilder("tr"), this.body = new TagBuilder("tbody")) : (this.header = this.node.createTHead(), this.body = this.node.createTBody()), Objects.isEmptyOrWhitespace(e) || (this.isHeadlessMode ? this.caption = new TagBuilder("caption").innerHTML(e) : (this.caption = this.node.createCaption(), this.caption.innerHTML = e)) } addHeader(...e) { if (0 === e.length) return this; const t = e.map((e => new TagBuilder("th").innerHTML(e))); return this.isHeadlessMode ? this.header.append(...t.map((e => e.buildHTML()))) : (null === this.node.tHead.firstChild && this.node.tHead.append(new TagBuilder("tr").build()), this.node.tHead.firstChild.append(...t.map((e => e.build())))), this } addRow(...e) { if (0 === e.length) return this; const t = e.map((e => new TagBuilder("td").innerHTML(e))); return this.isHeadlessMode ? this.body.append(new TagBuilder("tr").append(...t)) : this.body.append(new TagBuilder("tr").append(...t).build()), this } colgroup(e) { return this.colGroupBuilder = e, this } collapse() { return this.style({ "border-collapse": "collapse" }), this } setHeaders(...e) { return this.isHeadlessMode ? this.header = new TagBuilder("tr") : (this.node.deleteTHead(), this.header = this.node.createTHead()), e.length > 0 && this.addHeader(...e), this } setRows(...e) { return this.isHeadlessMode ? this.body = new TagBuilder("tbody") : this.body.innerHTML = "", e.length > 0 && e.forEach((e => this.addRow(...e))), this } clone() { var e; const t = new TableBuilder(null === (e = this.node) || void 0 === e ? void 0 : e.caption.innerHTML); return t.isCached = this.isCached, t.body = this.body, t.header = this.header, t.colGroupBuilder = this.colGroupBuilder, this.isHeadlessMode ? (t.caption = this.caption.clone(), t.hNode = this.hNode.clone(), t) : (t.caption = t.node.createCaption(), t.caption.innerHTML = this.caption.innerHTML, t.node = this.node.cloneNode(!0), t) } build() { return this.isCached || (this.isCached = !0, this.buildSections()), this.node } buildHTML() { return this.isCached || (this.isCached = !0, this.buildSections()), this.isHeadlessMode ? this.hNode.build() : this.node.outerHTML } buildSections() { this.isHeadlessMode && (this.append(new TagBuilder("thead").append(this.header)), this.append(this.body)), this.isHeadlessMode && null !== this.caption && (null !== this.colGroupBuilder && this.prepend(this.colGroupBuilder), this.prepend(this.caption)), null !== this.colGroupBuilder && (this.isHeadlessMode || null === this.caption ? this.isHeadlessMode ? this.prepend(this.colGroupBuilder) : this.node.prepend(this.colGroupBuilder.build()) : this.caption.insertAdjacentElement("afterend", this.colGroupBuilder.build())) } } class SlotBuilder extends TagBuilder { constructor(e, t, s) { super("slot", s), Objects.requireNonNull(t, "content in SlotBuilder"), e = Objects.requireNonNull(e, "name in SlotBuilder"), this.isHeadlessMode ? this.hNode.attr("name", e) : this.node.name = e, this.append(t) } } class TemplateBuilder extends TagBuilder { constructor(e) { super("template", e), this.styleBuilder = null, Objects.requireNonNull(e, "id in Template Builder") } addStylesToRoot(e) { return Objects.isDefined(e) ? (null !== this.styleBuilder ? this.styleBuilder.append(e) : this.styleBuilder = new TagBuilder("style").innerText(e), this) : this } addSlots(...e) { return Objects.isDefined(e) && 0 !== e.length ? (this.append(...e), this) : this } clone() { const e = new TemplateBuilder(this.tagId); return e.isCached = this.isCached, null !== this.styleBuilder && (e.styleBuilder = this.styleBuilder.clone()), this.isHeadlessMode ? e.hNode = this.hNode.clone() : e.node = this.node.cloneNode(!0), e } buildHTML() { return this.isCached ? this.hNode.build() : (this.isCached = !0, this.prepend(this.styleBuilder), this.isHeadlessMode ? this.hNode.build() : this.build().outerHTML) } build() { return this.isCached || (this.isCached = !0, this.prepend(this.styleBuilder)), this.node } } class SVGBuilder extends AbstractTagBuilder { constructor(e, t, s = "http://www.w3.org/2000/svg") { super("svg", t, s), Objects.isEmptyOrWhitespace(s) && Objects.requireNonNull(null, "xmlns"), Objects.isEmptyOrWhitespace(e) || this.attr("viewBox", e) } bounds(e, t) { return this.width(e), this.height(t), this } height(e) { return this.attr("height", e), this } width(e) { return this.attr("width", e), this } clone() { const e = new SVGBuilder; return e.isCached = this.isCached, this.isHeadlessMode ? e.hNode = this.hNode.clone() : e.node = this.node.cloneNode(!0), e } } class SVGElementBuilder extends AbstractTagBuilder { constructor(e, t = "http://www.w3.org/2000/svg", s) { super(e, s, t), Objects.isEmptyOrWhitespace(t) && Objects.requireNonNull(null, "xmlns") } fill(e) { return this.attr("fill", e), this } stroke(e, t) { return this.attr("stroke", e), this.attr("stroke-width", t), this } width(e) { return this.attr("width", e), this } height(e) { return this.attr("height", e), this } bounds(e, t) { return this.width(e), this.height(t), this } preserveAspectRatio(e) { return this.attr("preserveAspectRatio", e), this } x(e) { return this.attr("x", e), this } y(e) { return this.attr("y", e), this } viewBox(e) { return this.attr("viewBox", e), this } clone() { const e = new SVGElementBuilder(this.tagName); return e.isCached = this.isCached, this.isHeadlessMode ? e.hNode = this.hNode.clone() : e.node = this.node.cloneNode(!0), e } } "undefined" != typeof module && module.exports && (module.exports = { TagBuilder: TagBuilder, TagBuilderOptions: TagBuilderOptions, Objects: Objects, BlockquoteBuilder: BlockquoteBuilder, FieldsetBuilder: FieldsetBuilder, FigureBuilder: FigureBuilder, AnchorBuilder: AnchorBuilder, DownloadLinkBuilder: DownloadLinkBuilder, AreaBuilder: AreaBuilder, DownloadAreaBuilder: DownloadAreaBuilder, DataBuilder: DataBuilder, SpanBuilder: SpanBuilder, InputBuilder: InputBuilder, NumberInputBuilder: NumberInputBuilder, CheckboxInputBuilder: CheckboxInputBuilder, RadioInputBuilder: RadioInputBuilder, RangeInputBuilder: RangeInputBuilder, DateInputBuilder: DateInputBuilder, DateTimeLocalInputBuilder: DateTimeLocalInputBuilder, MonthInputBuilder: MonthInputBuilder, TimeInputBuilder: TimeInputBuilder, WeekInputBuilder: WeekInputBuilder, FileInputBuilder: FileInputBuilder, ImageInputBuilder: ImageInputBuilder, TextInputBuilder: TextInputBuilder, EmailInputBuilder: EmailInputBuilder, PasswordInputBuilder: PasswordInputBuilder, SearchInputBuilder: SearchInputBuilder, TelInputBuilder: TelInputBuilder, UrlInputBuilder: UrlInputBuilder, TextAreaBuilder: TextAreaBuilder, DataListBuilder: DataListBuilder, DLBuilder: DLBuilder, DetailsBuilder: DetailsBuilder, OptionBuilder: OptionBuilder, SelectBuilder: SelectBuilder, ListItemBuilder: ListItemBuilder, ListBuilder: ListBuilder, SourceBuilder: SourceBuilder, AudioBuilder: AudioBuilder, EmbedBuilder: EmbedBuilder, IframeBuilder: IframeBuilder, ImageBuilder: ImageBuilder, PictureBuilder: PictureBuilder, VideoBuilder: VideoBuilder, MeterBuilder: MeterBuilder, ProgressBuilder: ProgressBuilder, FormBuilder: FormBuilder, ScriptBuilder: ScriptBuilder, ColGroupBuilder: ColGroupBuilder, TableBuilder: TableBuilder, SlotBuilder: SlotBuilder, TemplateBuilder: TemplateBuilder, SVGBuilder: SVGBuilder, SVGElementBuilder: SVGElementBuilder });
//# sourceMappingURL=/sm/4674c035ad6776daaa715aaf54572dd5e422210b71d51237e4c4e14fed2a0e6c.map